
c-----------------------------------------------------------------------
c
c  USER SPECIFIED ROUTINES:
c
c     - boundary conditions
c     - initial conditions
c     - variable properties
c     - forcing function for fluid (f)
c     - forcing function for passive scalar (q)
c     - general purpose routine for checking errors etc.
c
c-----------------------------------------------------------------------
      subroutine usersol(tt, myshx, myshy, myshz, mysex, mysey, mysez)
      include 'SIZE'
      include 'TOTAL'
      include 'EMWAVE'
      include 'NEKUSE'
      include 'RK5'

      real tt
      real myshx(lx1,ly1,lz1,lelt)
      real myshy(lx1,ly1,lz1,lelt)
      real myshz(lx1,ly1,lz1,lelt)
      real mysex(lx1,ly1,lz1,lelt)
      real mysey(lx1,ly1,lz1,lelt)
      real mysez(lx1,ly1,lz1,lelt)
      real xmaxsize
      save xmaxsize

      do  i= 1,nx1*ny1*nz1*nelt
         xx= xm1(i,1,1,1)
         yy= ym1(i,1,1,1)
         zz= zm1(i,1,1,1)

       ! myshx(i,1,1,1) = 0
       ! myshy(i,1,1,1) = 0
       ! myshz(i,1,1,1) = 0
       ! mysex(i,1,1,1) = 0
       ! mysey(i,1,1,1) = 0
       ! mysez(i,1,1,1) = 0
      enddo

      return
      end
c-------------------------------------------------------------------
      subroutine userinc

      include 'SIZE'
      include 'TOTAL'
      include 'EMWAVE'
      include 'NEKUSE'
      include 'PML'
      include 'SCRATCH'
      include 'RK5'

      ! Add source terms to the fields given in src{e,h}{x,y,z}.
      ! Read file doc/rea-file.txt for specification.
      ! Since we want to make it possible to have several sources,
      ! we specify a `baseidx', relative to which all parameters are
      ! read.

      real    kx , ky , kz 
      real    wavelength
      real    impedence_freespace                                     
      real    impedence                                               

c ... presetting
      twopi  = 2.0*pi
      impedence_freespace=sqrt(permit_0/permea_0)

c ... spatial mode set  
      kx    = param(66)                  ! smodty=3: planewave
      ky    = param(67)                  
      kz    = param(68)              

      wavelength = param(69)*nmscale

      refractive_index= 1.33 !water
      refractive_index= 1.00
      kx = refractive_index*kx
      ky = refractive_index*ky
      kz = refractive_index*kz

      tmp= permea_0/(permit_0*refractive_index**2)
      impedence=1./sqrt(tmp)

      n= nx1*ny1*nz1*nelt

      do i= 1,n
         xx = xm1(i,1,1,1)
         yy = ym1(i,1,1,1)
         zz = zm1(i,1,1,1)

         sincex(i,1,1,1)=0
         sincey(i,1,1,1)= 
     $     cos(twopi/wavelength*(cspeed*rktime-(kx*xx+ky*yy+kz*zz)))
         sincez(i,1,1,1)= 0
         sinchx(i,1,1,1)= 0
         sinchy(i,1,1,1)= 0
         sinchz(i,1,1,1)= impedence*
     $     cos(twopi/wavelength*(cspeed*rktime-(kx*xx+ky*yy+kz*zz)))
      enddo

 
       do i= 1,n   
         xx = xm1(i,1,1,1)
         yy = ym1(i,1,1,1)
         zz = zm1(i,1,1,1)

         if     (incflag.eq.1) then
           if ((cspeed*rktime-xx).ge.xminval) then
              tfac=outpml(i,1,1,1)
           else
              tfac=0.0
           endif
         elseif (incflag.eq.-1) then
           if ((cspeed*rktime+xx).ge.xmaxval) then
              tfac=outpml(i,1,1,1)
           else
              tfac=0.0
           endif
         endif

         incex(i,1,1,1)= tfac*sincex(i,1,1,1)
         incey(i,1,1,1)= tfac*sincey(i,1,1,1)
         incez(i,1,1,1)= tfac*sincez(i,1,1,1)
         inchx(i,1,1,1)= tfac*sinchx(i,1,1,1)
         inchy(i,1,1,1)= tfac*sinchy(i,1,1,1)
         inchz(i,1,1,1)= tfac*sinchz(i,1,1,1)

      enddo

      ! call exitt

      return
      end
c-----------------------------------------------------------------------
      subroutine usersrc(baseidx,srchx,srchy,srchz,srcex,srcey,srcez)

      include 'SIZE'
      include 'TOTAL'
      include 'EMWAVE'
      include 'NEKUSE'
      include 'PML'
      include 'SCRATCH'

      ! Add source terms to the fields given in src{e,h}{x,y,z}.
      ! Read file doc/rea-file.txt for specification.
      ! Since we want to make it possible to have several sources,
      ! we specify a `baseidx', relative to which all parameters are
      ! read.

      integer baseidx

      real srchx(lx1,ly1,lz1,lelt),
     $     srchy(lx1,ly1,lz1,lelt),
     $     srchz(lx1,ly1,lz1,lelt),
     $     srcex(lx1,ly1,lz1,lelt),
     $     srcey(lx1,ly1,lz1,lelt),
     $     srcez(lx1,ly1,lz1,lelt)

      n= nx1*ny1*nz1*nelt

      do  i = 1,n                        

         xx = xm1(i,1,1,1)
         yy = ym1(i,1,1,1)
         zz = zm1(i,1,1,1)
         tmp= bm1(i,1,1,1)*outpml(i,1,1,1)

         srcey(i,1,1,1)=srcey(i,1,1,1)+incey(i,1,1,1)*tmp           
         srchz(i,1,1,1)=srchz(i,1,1,1)+inchz(i,1,1,1)*tmp          

      enddo

      return
      end
c-----------------------------------------------------------------------
      subroutine userini(tt, myhx, myhy, myhz, myex, myey, myez)
      include 'SIZE'
      include 'TOTAL'
      include 'EMWAVE'
      include 'NEKUSE'

      real tt
      real myhx(lx1,ly1,lz1,lelt)
      real myhy(lx1,ly1,lz1,lelt)
      real myhz(lx1,ly1,lz1,lelt)
      real myex(lx1,ly1,lz1,lelt)
      real myey(lx1,ly1,lz1,lelt)
      real myez(lx1,ly1,lz1,lelt)

      do i=1,nx1*ny1*nz1*nelt
        xx=XM1(i,1,1,1)
        yy=YM1(i,1,1,1)
        zz=ZM1(i,1,1,1)

        myhx(i,1,1,1) = 0
        myhy(i,1,1,1) = 0
        myhz(i,1,1,1) = 0
        myex(i,1,1,1) = 0
        myey(i,1,1,1) = 0
        myez(i,1,1,1) = 0
      enddo

      return
      end

c-----------------------------------------------------------------------
      subroutine uservp (ix,iy,iz,ielg)
      include 'SIZE'
      include 'TOTAL'
      include 'EMWAVE'
      include 'NEKUSE'

      integer  n, ix, iy, iz, ielg, iel
      real     pi, one, xcc, ycc, zcc, x1, y1, z1
      real     lambda, fc, wc                     

      iel=gllel(ielg)

      call usermedia   (ix,iy,iz,iel)

      if (IFDRUDE ) call userdrude (ix,iy,iz,iel)

      return
      end

c-----------------------------------------------------------------------

      subroutine usermedia(ix,iy,iz,iel) ! Vector form of userf
      include 'SIZE'
      include 'TOTAL'
      include 'EMWAVE'
      include 'NEKUSE'

      integer  n, ix, iy,iz, ieg
      real     pi, one, xcc, ycc, zcc, x1, y1, z1
      real     lambda, fc, wc                     

      udiff  = 0.
      utrans = 0.

      permea = permea_0             
      permit = permit_0                

      return
      end

c-----------------------------------------------------------------------
      subroutine userdrude(ix,iy,iz,iel) ! Vector form of userf

      include 'SIZE'
      include 'TOTAL'
      include 'EMWAVE'
      include 'NEKUSE'

      integer  n, ix, iy,iz, iel
      real     pi, one, xcc, ycc, zcc, x1, y1, z1
      real     rr, r2, rad, rad2                                      
      real     lambda, fc, wc                     


      if     (if_in_region(iel).eq.0) then ! free space
             permit      = permit_0
             permea      = permea_0
             drude_alpha = 0.0
             drude_beta  = 0.0

      elseif (if_in_region(iel).eq.1) then
             permit_r    = 1.33*1.33       ! water refractive index=1.33
             permit      = permit_0*permit_r
             permea      = permea_0
             drude_alpha = 0.0
             drude_beta  = 0.0

      elseif (if_in_region(iel).eq.2) then
             permit_r    = 1.5*1.5         ! glass 
             permit      = permit_0*permit_r
             permea      = permea_0
             drude_alpha = 0.0
             drude_beta  = 0.0

      elseif (if_in_region(iel).eq.-1) then
            !eV -> SI: conversion from eV to inverse seconds
             tmp =  (27.2114*2.41888e-17)
            ! permit_r    = 5.398334980
            ! gamma_p     = 0.068017714/tmp
            ! freq_p      = 9.200688/tmp

             permit_r    = 1.0000000000
             gamma_p     = 0.23670/tmp
             freq_p      = 7.32318/tmp

             permit      = permit_0*permit_r
             permea      = permea_0
             drude_alpha =-gamma_p
             drude_beta  = permit_0*freq_p**2
      else
            if (nid.eq.0) write(6,*) 'dielectric or metal:not defiened'
            call exitt
      endif

      return
      end

c-----------------------------------------------------------------------
      subroutine userpml(ix,iy,iz,iel) ! Vector form of userf
      include 'SIZE'
      include 'TOTAL'
      include 'EMWAVE'
      include 'NEKUSE'

      character*5 pmlside   

      n= nx1*ny1*nz1*nelt

      pmlR0 = 10.0**(-15)
      pmlM  = 2.0

      return
      end

c-----------------------------------------------------------------------
      subroutine userf  (ix,iy,iz,ieg)
      include 'SIZE'
      include 'TOTAL'
      include 'NEKUSE'

      integer ix, iy, iz, ieg
C
      return
      end
c-----------------------------------------------------------------------
      subroutine userq  (ix,iy,iz,ieg)
      include 'SIZE'
      include 'TOTAL'
      include 'NEKUSE'
C
      qvol   = 0.0
      source = 0.0

      return
      end
c-----------------------------------------------------------------------
      subroutine useric(ix,iy,iz,ieg)
      include 'SIZE'
      include 'TOTAL'
      include 'NEKUSE'
C
      return
      end
c-----------------------------------------------------------------------
      subroutine userbc (ix,iy,iz,iside,ieg)
      include 'SIZE'
      include 'TOTAL'
      include 'NEKUSE'

      ux=0.0
      uy=0.0
      uz=0.0
      temp=0.0

      return
      end
c-----------------------------------------------------------------------
      subroutine usrdat

      include 'SIZE'
      include 'TOTAL'
      include 'EMWAVE'
      include 'NEKUSE'

      return
      end

c-----------------------------------------------------------------------
      subroutine usrdat2

      include 'SIZE'
      include 'TOTAL'
      include 'EMWAVE'
      include 'NEKUSE'

      real     pi

      n    = nx1*ny1*nz1*nelv

c     ifxyo= .true.

      xmin = glmin(xm1,n)
      xmax = glmax(xm1,n)
      ymin = glmin(ym1,n)
      ymax = glmax(ym1,n)
      zmin = glmin(zm1,n)
      zmax = glmax(zm1,n)

      if (IFNM) then
          nmscale = 1.e-9
          sz = nmscale
          sx = 240.0*nmscale/(xmax-xmin) 
          sy = 100.0*nmscale/(ymax-ymin)
          if (IF3D) sz = nmscale
      else
          sx = 240.0/(xmax-xmin) 
          sy = 100.0/(ymax-ymin)
          if (IF3D) sz = 1.0
          nmscale = 1.0                
      endif

      if (if3d) then

      do i=1,n
         xm1(i,1,1,1) = sx*xm1(i,1,1,1)
         ym1(i,1,1,1) = sy*ym1(i,1,1,1)
         zm1(i,1,1,1) = sz*zm1(i,1,1,1)
      enddo

      else

      do i=1,n
         xm1(i,1,1,1) = sx*(xm1(i,1,1,1)-xmin)               
         ym1(i,1,1,1) = sy*(ym1(i,1,1,1)-ymin)                        
      enddo

      endif

      xmin = glmin(xm1,n)
      xmax = glmax(xm1,n)
      ymin = glmin(ym1,n)
      ymax = glmax(ym1,n)
      zmin = glmin(zm1,n)
      zmax = glmax(zm1,n)

      z1=  xmax*4.0/10.0
      z0=  xmax*5.0/10.0
      z2=  xmax*6.0/10.0

      y1=  ymax*1.0/4.0 
      y0=  ymax*2.0/4.0  
      y2=  ymax*3.0/4.0 

      nxy2 = (nx1+1)/2


      do ie=1,nelv

         xmid = xm1(nxy2,nxy2,1,ie)
         ymid = ym1(nxy2,nxy2,1,ie)
         zmid = zm1(nxy2,nxy2,1,ie)
         rmd2 = xmid*xmid + ymid*ymid

         !if_in_region(ie) = 0               ! default: free space

         if ((xmid.ge.z1).and.(xmid.le.z0)) then
              if_in_region(ie) = -1     ! Au  
         elseif (xmid.le.z1) then
              if_in_region(ie) =  0     ! SiO2 
         elseif (xmid.ge.z0) then
              if_in_region(ie) =  2     ! water 
         endif

      enddo

      xmin = glmin(xm1,n)
      xmax = glmax(xm1,n)
      ymin = glmin(ym1,n)
      ymax = glmax(ym1,n)

      write(6,*) 'xmin/xmax--',xmin,xmax,ymin,ymax
      !call exitt

      return
      end
c-----------------------------------------------------------------------
      subroutine surface_integration                 
      include 'SIZE'
      include 'TOTAL'
      include 'EMWAVE'
      include 'NEKUSE'

      integer icalld
      save    icalld
      data    icalld  /0/

      if (icalld.eq.0) then
          call cem_set_fc_ptr
          icalld = 1
      endif

      n=nx1*ny1*nz1*nelt

      do i=1,n
         workfld(i,1,1,1)=ex(i,1,1,1)**2+hx(i,1,1,1)**2
      enddo

      srfint=0.0
      do j=1,ncemface
         i=cemface(j)
         faceval= 0.1*faceid(i,1,1,1)*workfld(i,1,1,1)
         srfint = srfint+faceval*area(j,1,1,1)
      enddo

      return
      end
c-----------------------------------------------------------------------
      subroutine userchk
      include 'SIZE'
      include 'TOTAL'
      include 'EMWAVE'

      common /ccpu/ cpu_t,cpu_t0

c ... compute errors

      if (istep.le.10.or.mod(istep,iocomm).eq.0) then

        ntott = nx1*ny1*nz1*nelt
        nsrf  = nx1*nz1*nelt*6

        if (ifsol) then
          call usersol(time,shx,shy,shz,sex,sey,sez)
        else
          call rzero(shx, ntott) 
          call rzero(shy, ntott) 
          call rzero(shz, ntott) 
          call rzero(sex, ntott) 
          call rzero(sey, ntott) 
          call rzero(sez, ntott) 
        endif

        call sub3(ErrHX,SHX,HX,NTOTT) 
        call sub3(ErrHY,SHY,HY,NTOTT) 
        call sub3(ErrHZ,SHZ,HZ,NTOTT) 
        call sub3(ErrEX,SEX,EX,NTOTT) 
        call sub3(ErrEY,SEY,EY,NTOTT) 
        call sub3(ErrEZ,SEZ,EZ,NTOTT) 

        HXmr = glamax(ErrHX,NTOTT) 
        HYmr = glamax(ErrHY,NTOTT) 
        HZmr = glamax(ErrHZ,NTOTT) 
        EXmr = glamax(ErrEX,NTOTT) 
        EYmr = glamax(ErrEY,NTOTT) 
        EZmr = glamax(ErrEZ,NTOTT) 

        HXer = glsc3(ErrHX,bm1,ErrHX,NTOTT) / volvm1
        HYer = glsc3(ErrHY,bm1,ErrHY,NTOTT) / volvm1
        HZer = glsc3(ErrHZ,bm1,ErrHZ,NTOTT) / volvm1
        EXer = glsc3(ErrEX,bm1,ErrEX,NTOTT) / volvm1
        EYer = glsc3(ErrEY,bm1,ErrEY,NTOTT) / volvm1
        EZer = glsc3(ErrEZ,bm1,ErrEZ,NTOTT) / volvm1

        if (hxer.gt.0) hxer = sqrt(hxer)
        if (hyer.gt.0) hyer = sqrt(hyer)
        if (hzer.gt.0) hzer = sqrt(hzer)
        if (exer.gt.0) exer = sqrt(exer)
        if (eyer.gt.0) eyer = sqrt(eyer)
        if (ezer.gt.0) ezer = sqrt(ezer)


c ... compute max gap size at interfaces between elmts.

        call CEM_GAP                     

        HXgp = glamax(gHX,NSRF) 
        HYgp = glamax(gHY,NSRF) 
        HZgp = glamax(gHZ,NSRF) 
        EXgp = glamax(gEX,NSRF) 
        EYgp = glamax(gEY,NSRF) 
        EZgp = glamax(gEZ,NSRF) 

c ... print statement

        snel = nelt + .5
        snel = sqrt(snel)
        nels = snel
        nnn  = nx1-1
        npt1 = nnn*nels
        npts = nx1*ny1*nz1*nelt ! npts = npt1**ndim

        if (istep.eq.0)       cpu_p_t= 0
        if (istep.gt.0)       cpu_p_t= cpu_t/(npts*istep)
        if (istep.eq.nsteps)  cpu_p_t= glsum(cpu_p_t,1)/np

        if (nid.eq.0) then

          write(6,91) ISTEP,nelt,nels,nnn,npt1,npts
     $         ,time,dt,HXer,HYer,HZer,EXer,EYer,EZer,cpu_t,cpu_p_t
          write(6,95) ISTEP,nelt,nels,nnn,npt1,npts
     $         ,time,dt,HXmr,HYmr,HZmr,EXmr,EYmr,EZmr,cpu_t,cpu_p_t

 91       format(/,i5,3i5,i5,i9,1p9e10.3,e9.2,' CPU: L2  '  )
 95       format(  i5,3i5,i5,i9,1p9e10.3,e9.2,' CPU: Linf'  )

        endif ! nid=0

      endif

      call process_poynting

      return
      end

c-----------------------------------------------------------------------
      subroutine process_poynting
      include 'SIZE'
      include 'TOTAL'
      include 'EMWAVE'

      integer icalld
      save    icalld
      data    icalld /0/

      integer e,f,nkey,iisum
      save    nkey,iisum
      common /cpoynt/ flag(2*ldim,lelt)
      integer         flag

      if (icalld.eq.0) then  ! customize your selection here

         do e=1,nelv
         do f=1,2*ndim
            flag(f,e) = 0
         enddo
         enddo

c        user supplies z0 and z1 that bracket the surface of interest

         n= nx1*ny1*nz1*nelt
         xmin = glmin(xm1,n)
         xmax = glmax(xm1,n)
         ymin = glmin(ym1,n)
         ymax = glmax(ym1,n)
c        Find faces #6 and with z0 < z < z1:
          if     (incflag.eq. 1) then
                tsurface = (240-3*24)*nmscale 
          elseif (incflag.eq.-1) then
                tsurface = (3*24)*nmscale 
          endif
         zz_0= tsurface -1.0e-14
         zz_1= tsurface +1.0e-14
         write(6,*) 'tsurface  =',tsurface,zz_0,zz_1 

         nkey=1
         isum = 0
         f = 3          ! assume it's an upward pointing z face
         do e=1,nelv
            call fcsum2(zsum,asum,xm1,e,f)  ! f in prex notation
            if (asum.gt.0) zavg = zsum/asum
            if (zz_0.le.zavg.and.zavg.le.zz_1) then
               flag(f,e) = nkey
               isum = isum+1
         !write(6,*) 'checking face numbers =',xmax,zavg,f,e
            endif
         enddo
         iisum=iglsum(isum,1)
         if (nid.eq.0) write(6,*)
     $       'transmission surface face numbers =',iisum

         icalld = 1

      endif

      if (iisum.eq.0) then
         if (nid.eq.0)  write(6,*) 
     $      'integration surface:not correct',nkey,iisum
          call exitt
      endif
      !poynting vectors (avgSz,avgISz) computed: cem_energy 
        
      n = nx1*ny1*nz1*nelt

      ubar1 = 0
      ubar2 = 0
      ubar3 = 0
      atot1 = 0
      atot2 = 0
      atot3 = 0
      nfaces= 2*ndim

      if (ifscat) then
          call sub3(totex,ex,sincex,n)
          call sub3(totey,ey,sincey,n)
          call sub3(totez,ez,sincez,n)
          call sub3(tothx,hx,sinchx,n)
          call sub3(tothy,hy,sinchy,n)
          call sub3(tothz,hz,sinchz,n)

      call vcross (poytSx,poytSy,poytSz,
     $             totex,totey,totez,tothx,tothy,tothz,n)
      call vcross (poySx,poySy,poySz,ex,ey,ez,hx,hy,hz,n)
      call vcross (poyISx,poyISy,poyISz,
     $             sincex,sincey,sincez,sinchx,sinchy,sinchz,n)
      elseif (ifsftf) then
      call vcross (poySx,poySy,poySz,ex,ey,ez,hx,hy,hz,n)
      call vcross (poyISx,poyISy,poyISz,
     $             sincex,sincey,sincez,sinchx,sinchy,sinchz,n)
      endif

      do e = 1,nelv
      do f = 1,nfaces
         if (flag(f,e).eq.nkey) then ! add this to this average
            call fcsum2(usum1,asum1,poytSx,e,f)  ! f in prex notation
            call fcsum2(usum2,asum2,poySx,e,f)  ! f in prex notation
            call fcsum2(usum3,asum3,poyISx,e,f)  ! f in prex notation
            ubar1 = ubar1 + usum1
            ubar2 = ubar2 + usum2
            ubar3 = ubar3 + usum3
            atot1 = atot1 + asum1
            atot2 = atot2 + asum2
            atot3 = atot3 + asum3
            isum  = isum  + 1
         endif
      enddo
      enddo

      ubar1= glsum(ubar1,1)
      ubar2= glsum(ubar2,1)
      ubar3= glsum(ubar3,1)

      atot1= glsum(atot1,1)
      atot2= glsum(atot2,1)
      atot3= glsum(atot3,1)

      if (istep.ge.1) then
         if (nid.eq.0) write(33,1) nperiod,istep,time,dt,ubar1,ubar2,
     $        ubar3,cspeed,param(69)*nmscale,nopstep,n_period,nx1-1
      endif

      call trans_calculation(ubar2,trash,ubar3)

    1 format(2i9,1p7e25.15,3i5)

      return
      end

c-----------------------------------------------------------------------
      subroutine trans_calculation(ubar1,ubar2,ubar3)
      include 'SIZE'
      include 'TOTAL'
      include 'EMWAVE'
      real     ubar1,ubar2,ubar3

       if (mod(istep,nopstep).eq.1) then
          trans_tot =  0.0
          trans_inc =  0.0
       endif
       tmp = dt*cspeed/(param(69)*nmscale)
       trans_tot = trans_tot +ubar1*tmp
       trans_inc = trans_inc +ubar3*tmp
       trans_T   = 0 

       if ((mod(istep,nopstep).eq.0).and.(istep.gt.1)) then
          trans_T   = trans_tot/trans_inc
          write(6,2) nperiod,istep,trans_tot,trans_inc,trans_T
       endif

       if ((istep.eq.nsteps)) then
        if (nid.eq.0) write(6,*)  ' '
        if (nid.eq.0) then
           write(6,*) '==============================================='
           write(6,*)  n_period,'-th period:'
           write(6,*) '-----------------------------------------------'
           write(6,*) 'period=',(param(69)*nmscale)/cspeed
           write(6,*) 'finaltime=',dt*nsteps
           if (ifnm) then
              write(6,*) 'wavelength(nm)=',param(69)
           else
              write(6,*) 'wavelength= ',param(69)
           endif
           write(6,*) '-----------------------------------------------'
           transmit_t=trans_tot /trans_inc
           write(6,*) 'Transmission_Tot =',transmit_t
           write(6,*)  '=============================================='
        endif
       endif

    2 format('Transmission: period=',i5,'  istep=',i10,'  trans_tot=',
     $        e10.3,'  trans_inc=',e10.3,'  trans_T=',e10.3)



      return
      end
c-----------------------------------------------------------------------
