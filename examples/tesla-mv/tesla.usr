c-----------------------------------------------------------------------
c  USER SPECIFIED ROUTINES:
c
c     - boundary conditions
c     - initial conditions
c     - variable properties
c     - forcing function for fluid (f)
c     - forcing function for passive scalar (q)
c     - general purpose routine for checking errors etc.
c-----------------------------------------------------------------------
      subroutine userinc
      include 'SIZE'
      include 'TOTAL'
      include 'EMWAVE'
      include 'NEKUSE'

      return
      end
c-----------------------------------------------------------------------
      subroutine usersol(tt, myshx, myshy, myshz, mysex, mysey, mysez)
      include 'SIZE'
      include 'TOTAL'
      include 'EMWAVE'
      include 'NEKUSE'
      include 'POISSON'
      include 'PML'
      include 'BEAM'

      real tt
      real myshx(lx1,ly1,lz1,lelt)
      real myshy(lx1,ly1,lz1,lelt)
      real myshz(lx1,ly1,lz1,lelt)
      real mysex(lx1,ly1,lz1,lelt)
      real mysey(lx1,ly1,lz1,lelt)
      real mysez(lx1,ly1,lz1,lelt)

      real qq
      real ee1,ee2,ee3,hh1,hh2,hh3

      qq = 1.0

      n  = nx1*ny1*nz1*nelt

      do i=1,n
        ! mysex(i,1,1,1)=0 
        ! mysey(i,1,1,1)=0 
        ! mysez(i,1,1,1)=0 
        ! myshx(i,1,1,1)=0 
        ! myshy(i,1,1,1)=0 
        ! myshz(i,1,1,1)=0 
      enddo

      return
      end
       
c-----------------------------------------------------------------------
      subroutine usrdat

      include 'SIZE'
      include 'TOTAL'
      include 'EMWAVE'
      include 'NEKUSE'

      return
      end

c-----------------------------------------------------------------------
      subroutine usrdat2

      include 'SIZE'
      include 'TOTAL'
      include 'EMWAVE'
      include 'NEKUSE'
      include 'nekinput'

      ifxyo  =.true.


      cspeed = param(1)

      n = nx1*ny1*nz1*nelt

      do i=1,n
         xm1(i,1,1,1)= xm1(i,1,1,1)*nsc
         ym1(i,1,1,1)= ym1(i,1,1,1)*nsc
         zm1(i,1,1,1)= zm1(i,1,1,1)*nsc
      enddo

      zmax=glmax(zm1,n)
      zmin=glmin(zm1,n)
      ymax=glmax(ym1,n)
      ymin=glmin(ym1,n)
      xmax=glmax(xm1,n)
      xmin=glmin(xm1,n)
      rmax=glmax(xm1,n)

      zl(  1)=-641.944
      zl(nzl)= 642.944

      r0   = 26.0*nsc 
      rmax0= 39.0*nsc 

      do i=1,n
         xm1(i,1,1,1)= xm1(i,1,1,1)*rmax0/xmin
         ym1(i,1,1,1)= ym1(i,1,1,1)*rmax0/xmin
      enddo


      icnt = 0
      ient = 0
      do  i= 1,n
         xx= xm1(i,1,1,1)
         yy= ym1(i,1,1,1)
         zz= zm1(i,1,1,1)
         rr= (xx**2+yy**2)
         if (rr.gt.0) rr=sqrt(rr)
         theta= atan2(yy,xx)
         if (rr.ge.r0) then
         rsx=r0+(rmax0-r0)/(rmax-r0)*(rr-r0)
         rsy=r0+(rmax0-r0)/(rmax-r0)*(rr-r0)
         xm1(i,1,1,1)=rsx*cos(theta)
         ym1(i,1,1,1)=rsy*sin(theta)
         else
         xm1(i,1,1,1)=rr*cos(theta)
         ym1(i,1,1,1)=rr*sin(theta)
         endif
      enddo

      do  i= 1,n
         xx= xm1(i,1,1,1)
         yy= ym1(i,1,1,1)
         zz= zm1(i,1,1,1)
         rr= (xx**2+yy**2)
         theta= atan2(yy,xx)

         if (rr.gt.0) rr=sqrt(rr)
         if (rr.ge.r0) then    !!!!  caution

         do j  = 1,nzl-1       
            z1 = zl(j  ) 
            z2 = zl(j+1) 
            r1 = rl(j  ) 
            r2 = rl(j+1) 
            icnt=icnt+1
            ient=ient+1

            if      (arc(j).eq.1) then  ! circle 
               if (mod(icnt,2).eq.0) zcc=zl(j+1) 
               if (mod(icnt,2).eq.1) zcc=zl(j  ) 
               if (cup(j).eq. 0) aa =midrad**2          
               if (cup(j).eq. 0) rcc=midb-midrad                
               if (cup(j).eq.-1) aa =end1rad**2         
               if (cup(j).eq.-1) rcc=end1b-end1rad              
               if (cup(j).eq. 1) aa =end2rad**2         
               if (cup(j).eq. 1) rcc=end2b-end2rad              
            elseif  (arc(j).eq.-1) then  ! circle 
               if (mod(ient,2).eq.0) zcc=zl(j  ) 
               if (mod(ient,2).eq.1) zcc=zl(j+1) 
               if (ient.eq.1)        zcc=zl(j)        
               if (cup(j).eq. 0) aa =midriz**2          
               if (cup(j).eq. 0) bb =midrir**2          
               if (cup(j).eq. 0) rcc=mida+midrir                
               if (cup(j).eq.-1) aa =end1riz**2         
               if (cup(j).eq.-1) bb =end1rir**2         
               if (cup(j).eq.-1) rcc=end1a+end1rir              
               if (cup(j).eq. 1) aa =end2riz**2         
               if (cup(j).eq. 1) bb =end2rir**2         
               if (cup(j).eq. 1) rcc=end2a+end2rir              
            endif

            if ((zz.ge.z1).and.(zz.le.z2)) then

              if       (arc(j).eq.1) then  ! circle 
                !write(6,*) 'cc--',i,j,zcc,rcc,rmax-r0
                zsc=zcc    
                rsc=rcc    
                rzz=(aa-(zz-zsc)**2)
                rsx=sqrt(rzz)+rsc  
                rsy=sqrt(rzz)+rsc  
                rsx=r0+(rsx-r0)/(rmax-r0)*(rr-r0)
                rsy=r0+(rsy-r0)/(rmax-r0)*(rr-r0)
                xm1(i,1,1,1)=rsx*cos(theta)
                ym1(i,1,1,1)=rsy*sin(theta)

              elseif  (arc(j).eq.0) then  ! straight
                !write(6,*) 'ss--',i,j,r2,r1,z2,z1,rmax-r0
                rsx=(r2-r1)/(z2-z1)*(zz-z1)+r1
                rsy=(r2-r1)/(z2-z1)*(zz-z1)+r1
                rsx=r0+(rsx-r0)/(rmax-r0)*(rr-r0)
                rsy=r0+(rsy-r0)/(rmax-r0)*(rr-r0)
                xm1(i,1,1,1)=rsx*cos(theta)
                ym1(i,1,1,1)=rsy*sin(theta)

              elseif  (arc(j).eq.-1) then  ! ellipse 
                !write(6,*) 'ee--',i,j,aa,rmax-r0,bb,zcc,rcc
                zsc=zcc    
                rsc=rcc    
                rzz=bb*(aa-(zz-zsc)**2)
                rzz=rzz/aa                                     
                rsx=-sqrt(rzz)+rsc  
                rsy=-sqrt(rzz)+rsc  
                rsx=r0+(rsx-r0)/(rmax-r0)*(rr-r0)
                rsy=r0+(rsy-r0)/(rmax-r0)*(rr-r0)
                xm1(i,1,1,1)=rsx*cos(theta)
                ym1(i,1,1,1)=rsy*sin(theta)

              endif

            endif

         enddo
         endif

      enddo

      return
      end

c-----------------------------------------------------------------------
      subroutine userini(tt, myhx, myhy, myhz, myex, myey, myez)

      include 'SIZE'
      include 'TOTAL'
      include 'EMWAVE'
      include 'NEKUSE'
      include 'POISSON'
      include 'POISSON2D'
      include 'BEAM'

      real tt
      real myhx(lx1,ly1,lz1,lelt)
      real myhy(lx1,ly1,lz1,lelt)
      real myhz(lx1,ly1,lz1,lelt)
      real myex(lx1,ly1,lz1,lelt)
      real myey(lx1,ly1,lz1,lelt)
      real myez(lx1,ly1,lz1,lelt)

      n=nx1*ny1*nz1*nelt

      call poisson2d

      return
      end
c-----------------------------------------------------------------------
      subroutine usersrc(baseidx,srchx,srchy,srchz,srcex,srcey,srcez)
      include 'SIZE'
      include 'TOTAL'
      include 'EMWAVE'
      include 'NEKUSE'
      include 'PML'
      include 'RK5'
      include 'BEAM'
      include 'WAKEPOT'
      include 'MOVWIN' 

      real    srchx(lx1,ly1,lz1,lelt),
     $        srchy(lx1,ly1,lz1,lelt),
     $        srchz(lx1,ly1,lz1,lelt),
     $        srcex(lx1,ly1,lz1,lelt),
     $        srcey(lx1,ly1,lz1,lelt),
     $        srcez(lx1,ly1,lz1,lelt) 

      integer i, n
      real    xx, yy, zz, rr, rho, phi
      real    sqrtwopi,twopi, charge, scalfac 
      real    hrho, hphi, erho, ephi 

      integer icalld
      save    icalld
      data    icalld /0/           

      integer icalld0
      save    icalld0
      data    icalld0 /0/           

      integer e
      real    zjump
      save    zjump

      real    zposition0
      save    zposition0

      real    shift0
      save    shift0
           
      n    = nx1*ny1*nz1*nelt
      nxyz = nx1*ny1*nz1          

      if (icalld.eq.0) then

        if (nid.eq.0) then
           write(6,*) 'rsigma    =',rsigma
           write(6,*) 'zsigma    =',zsigma
           write(6,*) 'zposition =',zposition
           write(6,*)                              
        endif

        zposition0 = zposition
        shift0 = 0
        icalld = 1

      endif

      do i=1,n
         xx= xm1(i,1,1,1)
         yy= ym1(i,1,1,1)
         rr= sqrt(xx**2+yy**2)
         rdensity= bnch_rdensity(rr)
         bnchr(i,1,1,1)= rdensity*cspeed*bm1(i,1,1,1)             
      enddo

      if    (mwcalld.eq.1) then
        if  (icalld0.eq.0) then
            shift  = zjump
            shift0 = shift0 + shift
        endif
        icalld0  = icalld0 + 1
        zposition= zposition0
        zmini    = glmin(zm1,n) 
        !write(6,*) 'shift0',istep,shift0,shift,zposition0,zposition

      elseif (mwcalld.eq.0) then
        zmin= glmin(zm1,n) 
        do e=1,nwin2d               
           zjump2= vlmax(zm1(1,1,1,e),nxyz) 
           zjump1= vlmin(zm1(1,1,1,e),nxyz) 
           zjump = zjump2-zjump1
        enddo
        icalld0= 0
      endif

      bnch_normal  = 1.0/(sqrt(2.0*pi)*zsigma) 
      arg = -0.5/(zsigma)**2
      

      do i=1,n
         xx= xm1(i,1,1,1)
         yy= ym1(i,1,1,1)
         zz= zm1(i,1,1,1)
         zz= zz-cspeed*time-zposition0-shift0
         rr= sqrt(xx**2+yy**2)
         rdensity= bnch_rdensity(rr)
         bnchr(i,1,1,1)= rdensity*cspeed*bm1(i,1,1,1)             
         srcez(i,1,1,1)= srcez(i,1,1,1)
     $   -exp(arg*zz*zz)*bnch_normal*bnchr(i,1,1,1)
      enddo

      return
      end
c-----------------------------------------------------------------------
      subroutine uservp (ix,iy,iz,iel)
      include 'SIZE'
      include 'TOTAL'
      include 'EMWAVE'
      include 'NEKUSE'

      integer  n, ix, iy, iz, ieg
      real     pi, one, xcc, ycc, zcc, x1, y1, z1
      real     lambda, fc, wc                     

      call usermedia   (ix,iy,iz,iel)

      if (IFPML)    call userpml  (ix,iy,iz,iel)
      if (IFWAKE)   call userwake (ix,iy,iz,iel)

      return
      end
c-----------------------------------------------------------------------
      subroutine usermedia(ix,iy,iz,iel) ! Vector form of userf
      include 'SIZE'
      include 'TOTAL'
      include 'EMWAVE'
      include 'NEKUSE'

      integer  n, ix, iy,iz, ieg
      real     pi, one, xcc, ycc, zcc, x1, y1, z1
      real     lambda, fc, wc                     

      udiff  = 0.
      utrans = 0.

      permea = param(3) ! permea_0             
      permit = param(2) ! permit_0                

      return
      end
c-----------------------------------------------------------------------
      subroutine userdrude(ix,iy,iz,iel) ! Vector form of userf
      include 'SIZE'
      include 'TOTAL'
      include 'EMWAVE'
      include 'NEKUSE'

      integer  n, ix, iy,iz, iel

      return
      end
c-----------------------------------------------------------------------
      subroutine userpml(ix,iy,iz,iel) ! Vector form of userf
      include 'SIZE'
      include 'TOTAL'
      include 'EMWAVE'
      include 'NEKUSE'


      return
      end
c-----------------------------------------------------------------------
      subroutine userf  (ix,iy,iz,ieg)
      include 'SIZE'
      include 'TOTAL'
      include 'NEKUSE'

      integer ix, iy, iz, ieg
C
      return
      end
c-----------------------------------------------------------------------
      subroutine userq  (ix,iy,iz,ieg)
      include 'SIZE'
      include 'TOTAL'
      include 'EMWAVE'
      include 'NEKUSE'
      include 'PML'
      include 'BEAM'

      integer  icalld
      save     icalld
      data     icalld /0/

      save     qq
      integer  ix, iy, iz, ieg

      n  = nx1*ny1*nz1*nelt
      qq = 1

      xx   = xm1(ix,iy,iz,ieg)
      yy   = ym1(ix,iy,iz,ieg)
      zz   = zm1(ix,iy,iz,ieg)
      rr   = sqrt(xx**2+yy**2)
      theta= atan2(yy,xx)
      reps = epsilo(ix,iy,iz,ieg)

      zz      = bnch_z  (time,zz)  
      rdensity= bnch_rdensity(rr)
      zdensity= bnch_zdensity(zz)
      charge  = rdensity *zdensity

      qvol    = charge/reps    
      chgq (ix,iy,iz,ieg) = qvol

      if (abs(qvol).lt.1e-14) qvol=0.0

      source  = 0.0

      return
      end
c-----------------------------------------------------------------------
      subroutine useric (ix,iy,iz,ieg)
      include 'SIZE'
      include 'TOTAL'
      include 'NEKUSE'

      return
      end
c-----------------------------------------------------------------------
      subroutine userbc (ix,iy,iz,iside,ieg)
      include 'SIZE'
      include 'TOTAL'
      include 'NEKUSE'

      ux=0.0
      uy=0.0
      uz=0.0
      temp=0.0

      return
      end
c-----------------------------------------------------------------------
      subroutine userwake(ix,iy,iz,ieg) 
      include 'SIZE'
      include 'TOTAL'
      include 'EMWAVE'
      include 'NEKUSE'

      return
      end
c-----------------------------------------------------------------------
      subroutine userchk                   
      include 'SIZE'
      include 'TOTAL'
      include 'EMWAVE'
      common /ccpu/ cpu_t,cpu_t0

c ... compute errors
      
      if (istep.le.10.or.mod(istep,iocomm).eq.0) then

        ntott = nx1*ny1*nz1*nelt
        nsrf  = nx1*nz1*nelt*6

        if (ifsol) then
            call usersol(time,shx,shy,shz,sex,sey,sez)
        else
            call rzero(shx, ntott) 
            call rzero(shy, ntott) 
            call rzero(shz, ntott) 
            call rzero(sex, ntott) 
            call rzero(sey, ntott) 
            call rzero(sez, ntott) 
        endif

        call sub3(ErrHX,SHX,HX,NTOTT) 
        call sub3(ErrHY,SHY,HY,NTOTT) 
        call sub3(ErrHZ,SHZ,HZ,NTOTT) 
        call sub3(ErrEX,SEX,EX,NTOTT) 
        call sub3(ErrEY,SEY,EY,NTOTT) 
        call sub3(ErrEZ,SEZ,EZ,NTOTT) 

        HXmr = glamax(ErrHX,NTOTT) 
        HYmr = glamax(ErrHY,NTOTT) 
        HZmr = glamax(ErrHZ,NTOTT) 
        EXmr = glamax(ErrEX,NTOTT) 
        EYmr = glamax(ErrEY,NTOTT) 
        EZmr = glamax(ErrEZ,NTOTT) 

        hhx=glmax(hx,ntott)
        hhy=glmax(hy,ntott)
        hhz=glmax(hz,ntott)
        hex=glmax(ex,ntott)
        hey=glmax(ey,ntott)
        hez=glmax(ez,ntott)

        HXer = glsc3(ErrHX,bm1,ErrHX,NTOTT)/ volvm1
        HYer = glsc3(ErrHY,bm1,ErrHY,NTOTT)/ volvm1
        HZer = glsc3(ErrHZ,bm1,ErrHZ,NTOTT)/ volvm1
        EXer = glsc3(ErrEX,bm1,ErrEX,NTOTT)/ volvm1
        EYer = glsc3(ErrEY,bm1,ErrEY,NTOTT)/ volvm1
        EZer = glsc3(ErrEZ,bm1,ErrEZ,NTOTT)/ volvm1

        if (hxer.gt.0) hxer = sqrt(hxer)
        if (hyer.gt.0) hyer = sqrt(hyer)
        if (hzer.gt.0) hzer = sqrt(hzer)
        if (exer.gt.0) exer = sqrt(exer)
        if (eyer.gt.0) eyer = sqrt(eyer)
        if (ezer.gt.0) ezer = sqrt(ezer)


c ... compute max gap size at interfaces between elmts.

        !call CEM_GAP                     
        !HXgp = glamax(gHX,NSRF) 
        !HYgp = glamax(gHY,NSRF) 
        !HZgp = glamax(gHZ,NSRF) 
        !EXgp = glamax(gEX,NSRF) 
        !EYgp = glamax(gEY,NSRF) 
        !EZgp = glamax(gEZ,NSRF) 

c ... print statement

        snel = nelt + .5
        snel = sqrt(snel)
        nels = snel
        nnn  = nx1-1
        npt1 = nnn*nels
        npts = nx1*ny1*nz1*nelt ! npts = npt1**ndim

        if (istep.eq.0)       cpu_p_t= 0                    
        if (istep.gt.0)       cpu_p_t= cpu_t/(npts*istep)
        if (istep.eq.nsteps)  cpu_p_t= glsum(cpu_p_t,1)/np

        if (nid.eq.0) then

          !h2err = hxer**2 + hyer**2
          !if (h2err.gt.0) h2err = sqrt(h2err)
          !hmgp = max(hxgp,hygp)
          !hmer = max(hxmr,hymr)

          write(6,91) ISTEP,nelt,nels,nnn,npt1,npts
     $         ,time,dt,HXer,HYer,HZer,EXer,EYer,EZer,cpu_t,cpu_p_t
          write(6,95) ISTEP,nelt,nels,nnn,npt1,npts
     $         ,time,dt,HXmr,HYmr,HZmr,EXmr,EYmr,EZmr,cpu_t,cpu_p_t

 91       format(/,i5,3i5,i5,i9,1p9e10.3,e9.2,' CPU: L2  '  )
 95       format(  i5,3i5,i5,i9,1p9e10.3,e9.2,' CPU: Linf'  )

c93       format(i7,1pe10.3)

        endif ! nid=0

      endif

      return
      end
c-----------------------------------------------------------------------
