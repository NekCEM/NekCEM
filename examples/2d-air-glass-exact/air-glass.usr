c-----------------------------------------------------------------------
c
c  USER SPECIFIED ROUTINES:
c
c     - boundary conditions
c     - initial conditions
c     - variable properties
c     - forcing function for fluid (f)
c     - forcing function for passive scalar (q)
c     - general purpose routine for checking errors etc.
c
c-----------------------------------------------------------------------
      subroutine userinc
      include 'SIZE'
      include 'TOTAL'
      include 'EMWAVE'
      include 'NEKUSE'
      include 'PML'
      include 'SCRATCH'

      return
      end

c-----------------------------------------------------------------------
      subroutine usersrc(baseidx,srchx,srchy,srchz,srcex,srcey,srcez)
      include 'SIZE'
      include 'TOTAL'
      include 'EMWAVE'
      include 'NEKUSE'
      include 'PML'
      include 'SCRATCH'

      integer baseidx

      real srchx(lx1,ly1,lz1,lelt),
     $     srchy(lx1,ly1,lz1,lelt),
     $     srchz(lx1,ly1,lz1,lelt),
     $     srcex(lx1,ly1,lz1,lelt),
     $     srcey(lx1,ly1,lz1,lelt),
     $     srcez(lx1,ly1,lz1,lelt)



      return
      end
c-----------------------------------------------------------------------
      subroutine userini(tt, myhx, myhy, myhz, myex, myey, myez)

      include 'SIZE'
      include 'TOTAL'
      include 'EMWAVE'
      include 'NEKUSE'

      real tt
      real myhx(lx1,ly1,lz1,lelt)
      real myhy(lx1,ly1,lz1,lelt)
      real myhz(lx1,ly1,lz1,lelt)
      real myex(lx1,ly1,lz1,lelt)
      real myey(lx1,ly1,lz1,lelt)
      real myez(lx1,ly1,lz1,lelt)

      do i=1,nx1*ny1*nz1*nelt
         myhx(i,1,1,1) = 0
         myhy(i,1,1,1) = 0
         myhz(i,1,1,1) = 0
         myex(i,1,1,1) = 0
         myey(i,1,1,1) = 0
         myez(i,1,1,1) = 0
      enddo

      return
      end
c-----------------------------------------------------------------------
      subroutine uservp (ix,iy,iz,ielg)

      include 'SIZE'
      include 'TOTAL'
      include 'EMWAVE'
      include 'NEKUSE'

      integer  n, ix, iy, iz, iel, ielg
      real     pi, one, xcc, ycc, zcc, x1, y1, z1
      real     lambda, fc, wc                     

      iel= gllel(ielg)
      
      permea = permea_0             
      permit = permit_0                
      drude_alpha = 0.0               
      drude_beta  = 0.0                         

      call userdrude (ix,iy,iz,iel)

      return
      end
c-----------------------------------------------------------------------
      subroutine userdrude(ix,iy,iz,iel) ! Vector form of userf
      include 'SIZE'
      include 'TOTAL'
      include 'EMWAVE'
      include 'NEKUSE'

      integer  n, ix, iy, iz, iel
      real     permit_0, permea_0, permit_r
      real     gamma_p, freq_p                                     

c ... if_in_region(iel)= -1,-2,-3, ... define metallic regions
c ... if_in_region(iel)=  0        ... define free space          
c ... if_in_region(iel)=  1, 2, 3, ... define dielectric regions

      if     (if_in_region(iel).eq.0) then ! free space
            permit      = permit_0
            permea      = permea_0
            drude_alpha = 0.0               
            drude_beta  = 0.0                         
      elseif (if_in_region(iel).eq.1) then
            permit_r    = 2.0*2.0 !glass 
            permit      = permit_0*permit_r
            permea      = permea_0 
            drude_alpha = 0.0               
            drude_beta  = 0.0                         
      elseif (if_in_region(iel).eq.2) then
            permit_r    = 1.5*1.5 !glass 
            permit      = permit_0*permit_r
            permea      = permea_0 
            drude_alpha = 0.0               
            drude_beta  = 0.0                         
      else
            if (nid.eq.0) write(6,*) 'dielectric or metal:not defiened' 
            call exitt
      endif

      return
      end
c-----------------------------------------------------------------------
      subroutine userf  (ix,iy,iz,ieg)
      include 'SIZE'
      include 'TOTAL'
      include 'NEKUSE'

      integer ix, iy, iz, ieg
C
      return
      end
c-----------------------------------------------------------------------
      subroutine userq  (ix,iy,iz,ieg)
      include 'SIZE'
      include 'TOTAL'
      include 'NEKUSE'
C
      qvol   = 0.0
      source = 0.0

      return
      end
c-----------------------------------------------------------------------
      subroutine useric  (ix,iy,iz,ieg)
      include 'SIZE'
      include 'TOTAL'
      include 'NEKUSE'
C
      return
      end
c-----------------------------------------------------------------------
      subroutine userbc (ix,iy,iz,iside,ieg)
      include 'SIZE'
      include 'TOTAL'
      include 'NEKUSE'

      return
      end
c-----------------------------------------------------------------------
      subroutine usrdat

      include 'SIZE'
      include 'TOTAL'
      include 'EMWAVE'
      include 'NEKUSE'
      integer i,e


      return
      end

c-----------------------------------------------------------------------
      subroutine usrdat2

      include 'SIZE'
      include 'TOTAL'
      include 'EMWAVE'
      include 'NEKUSE'

      integer  e
      real     pi

      n    = nx1*ny1*nz1*nelv

c     ifxyo= .true.

      xmin = glmin(xm1,n)
      xmax = glmax(xm1,n)
      ymin = glmin(ym1,n)
      ymax = glmax(ym1,n)
      zmin = glmin(zm1,n)
      zmax = glmax(zm1,n)

c     This is the nano/meter rescaling

      sscale = 1.0 ! 2*pi/(zmax-zmin)            

      if (IFNM) then
          sx = sscale*nmscale
          sy = sscale*nmscale
          sz = sscale*nmscale
      else
          sx = 1./50.0                          
          sy = 1./50.0     
          sz = 1./50.0     !4.0/200.0                       
          nmscale = 1.0                       
      endif

      if (if3d) then

        do e=1,nelt            
        do i=1,nx1*ny1*nz1
           xm1(i,1,1,e) = sx*xm1(i,1,1,e)                
           ym1(i,1,1,e) = sy*ym1(i,1,1,e)                        
           zm1(i,1,1,e) = sz*zm1(i,1,1,e)               
        enddo
        enddo

      else
        do e=1,nelt            
        do i=1,nx1*ny1*nz1
           xm1(i,1,1,e) = sx*xm1(i,1,1,e)               
           ym1(i,1,1,e) = sy*ym1(i,1,1,e)                        
        enddo
        enddo

      endif 
       

c     Determine which elements are in the cylinder (r<50)

      nxyz = nx1*ny1*nz1
      r02  = r0*r0
      nxy2 = (nx1+1)/2

      z0=  0.0*nmscale

      do e=1,nelv

         xmid = xm1(nxy2,nxy2,1,e)
         ymid = ym1(nxy2,nxy2,1,e)

         if     (xmid.ge.z0) then
             if_in_region(e) = 2 ! glass 
         elseif (xmid.le.z0) then
             if_in_region(e) = 0 ! air  
         endif

      enddo

      do e=1,nelv
      do i=1,nx1*ny1*nz1
         xmid = xm1(nxy2,nxy2,1,e)
         ymid = ym1(nxy2,nxy2,1,e)
         if     (if_in_region(e).eq.0) then
                 sx=1.0            
                 sy=1.0
         elseif (if_in_region(e).eq.2) then
                 sx=1.0/1.5
                 sy=1.0
         endif 
         xm1(i,1,1,e) = sx*xm1(i,1,1,e)               
         ym1(i,1,1,e) = sy*ym1(i,1,1,e)                        
      enddo
      enddo

      return
      end
c-----------------------------------------------------------------------
      subroutine usersol(tt, myshx, myshy, myshz, mysex, mysey, mysez)
c-----------------------------------------------------------------------
      include 'SIZE'
      include 'TOTAL'
      include 'EMWAVE'
      include 'NEKUSE'
      include 'GEOMBOUND'

      real tt,xx,yy,zz
      real myshx(lx1,ly1,lz1,lelt)
      real myshy(lx1,ly1,lz1,lelt)
      real myshz(lx1,ly1,lz1,lelt)
      real mysex(lx1,ly1,lz1,lelt)
      real mysey(lx1,ly1,lz1,lelt)
      real mysez(lx1,ly1,lz1,lelt)

      integer e                          

      n = nx1*ny1*nz1*nelt

      twopi= 2.0*pi
      eta_1= 1.5 !refractive index for medium 2 
      eta_2= 1.0 !refractive index for medium 1            
      eta_3= eta_1/eta_2  

      Ttr  = 2.0/(1+eta_3)
      Rre  =(1-eta_3)/(1+eta_3)                    

      Rre2 = Rre**2
      Ttr2 = 1-Rre2  

      !write(6,*) 'T, R', Ttr,Rre,Ttr2,Rre2 
      !call exitt

      wavelength = param(69)*nmscale

      E_i = 1.0
      E_r = Rre*E_i
      E_t = Ttr*E_i

      !write(6,*) 'E_i,E_r,E_t',E_i,E_r,E_t  
      !call exitt
 
      do e=1,nelt
      do i=1,nx1*ny1*nz1

            xx =xm1(i,1,1,e)                
            yy =ym1(i,1,1,e)                
            zz =zm1(i,1,1,e)                

            if (if_in_region(e).eq.0) then

             tmp1 = cos(twopi/wavelength*(cspeed*tt-eta_2*xx))
             tmp2 = cos(twopi/wavelength*(cspeed*tt+eta_2*xx))
          
             myshx(i,1,1,e)= 0.0                              
             myshy(i,1,1,e)= 0.0                                       
             myshz(i,1,1,e)=(E_i*tmp1-E_r*tmp2)/sqrt(1.0/eta_2**2)
             mysex(i,1,1,e)= 0.0                                  
             mysey(i,1,1,e)= E_i*tmp1+E_r*tmp2                
             mysez(i,1,1,e)= 0.0     

            elseif (if_in_region(e).eq.2) then

             tmp2 = cos(twopi/wavelength*(cspeed*tt-eta_1*xx))
          
             myshx(i,1,1,e)= 0.0                              
             myshy(i,1,1,e)= 0.0     
             myshz(i,1,1,e)= E_t*tmp2/sqrt(1.0/eta_1**2) 
             mysex(i,1,1,e)= 0.0                                  
             mysey(i,1,1,e)= E_t*tmp2
             mysez(i,1,1,e)= 0.0     

            endif

            tmp = cos(twopi/wavelength*(cspeed*tt-eta_2*xx))
            incey (i,1,1,e)= E_i*tmp
            inchz (i,1,1,e)= E_i*tmp/sqrt(1.0/eta_2**2)

      enddo
      enddo

      return
      end
c-----------------------------------------------------------------------
      subroutine userchk
      include 'SIZE'
      include 'TOTAL'
      include 'EMWAVE'

      common /ccpu/ cpu_t,cpu_t0

c ... compute errors

      if ((istep.le.10).or.(mod(istep,iocomm).eq.0)
     $   .or.(istep.eq.nsteps)) then


        ntott = nx1*ny1*nz1*nelt
        nsrf  = nx1*nz1*nelt*6

        if (ifsol) then
          call usersol(time,shx,shy,shz,sex,sey,sez)
        else
          call rzero(shx, ntott) 
          call rzero(shy, ntott) 
          call rzero(shz, ntott) 
          call rzero(sex, ntott) 
          call rzero(sey, ntott) 
          call rzero(sez, ntott) 
        endif

        call sub3(ErrHX,SHX,HX,NTOTT) 
        call sub3(ErrHY,SHY,HY,NTOTT) 
        call sub3(ErrHZ,SHZ,HZ,NTOTT) 
        call sub3(ErrEX,SEX,EX,NTOTT) 
        call sub3(ErrEY,SEY,EY,NTOTT) 
        call sub3(ErrEZ,SEZ,EZ,NTOTT) 

        HXmr = glamax(ErrHX,NTOTT) 
        HYmr = glamax(ErrHY,NTOTT) 
        HZmr = glamax(ErrHZ,NTOTT) 
        EXmr = glamax(ErrEX,NTOTT) 
        EYmr = glamax(ErrEY,NTOTT) 
        EZmr = glamax(ErrEZ,NTOTT) 

        HXer = glsc3(ErrHX,bm1,ErrHX,NTOTT) / volvm1
        HYer = glsc3(ErrHY,bm1,ErrHY,NTOTT) / volvm1
        HZer = glsc3(ErrHZ,bm1,ErrHZ,NTOTT) / volvm1
        EXer = glsc3(ErrEX,bm1,ErrEX,NTOTT) / volvm1
        EYer = glsc3(ErrEY,bm1,ErrEY,NTOTT) / volvm1
        EZer = glsc3(ErrEZ,bm1,ErrEZ,NTOTT) / volvm1

        if (hxer.gt.0) hxer = sqrt(hxer)
        if (hyer.gt.0) hyer = sqrt(hyer)
        if (hzer.gt.0) hzer = sqrt(hzer)
        if (exer.gt.0) exer = sqrt(exer)
        if (eyer.gt.0) eyer = sqrt(eyer)
        if (ezer.gt.0) ezer = sqrt(ezer)


c ... compute max gap size at interfaces between elmts.

        call CEM_GAP                     

        HXgp = glamax(gHX,NSRF) 
        HYgp = glamax(gHY,NSRF) 
        HZgp = glamax(gHZ,NSRF) 
        EXgp = glamax(gEX,NSRF) 
        EYgp = glamax(gEY,NSRF) 
        EZgp = glamax(gEZ,NSRF) 

c ... print statement

        snel = nelt + .5
        snel = sqrt(snel)
        nels = snel
        nnn  = nx1-1
        npt1 = nnn*nels
        npts = nx1*ny1*nz1*nelt ! npts = npt1**ndim

        if (istep.eq.0)       cpu_p_t= 0
        if (istep.gt.0)       cpu_p_t= cpu_t/(npts*istep)
        if (istep.eq.nsteps)  cpu_p_t= glsum(cpu_p_t,1)/np

        if (nid.eq.0) then

          write(6,91) ISTEP,nelt,nels,nnn,npt1,npts
     $         ,time,dt,HXer,HYer,HZer,EXer,EYer,EZer,cpu_t,cpu_p_t
          write(6,95) ISTEP,nelt,nels,nnn,npt1,npts
     $         ,time,dt,HXmr,HYmr,HZmr,EXmr,EYmr,EZmr,cpu_t,cpu_p_t

 91       format(/,i9,3i5,i5,i9,1p9e12.3,e9.2,' CPU: L2  '  )
 95       format(  i9,3i5,i5,i9,1p9e12.3,e9.2,' CPU: Linf'  )

        endif ! nid=0
      
      endif

      call process_poynting 

      return
      end

c-----------------------------------------------------------------------
      subroutine process_poynting
      include 'SIZE'
      include 'TOTAL'
      include 'EMWAVE'

      integer icalld
      save    icalld
      data    icalld /0/

      integer e,f,nkey,iisum
      save    nkey,iisum

      common /cpoynt/ flag(2*ldim,lelt)
      integer         flag

      if (icalld.eq.0) then  ! customize your selection here

         do e=1,nelv
         do f=1,2*ndim
            flag(f,e) = 0
         enddo
         enddo

c        user supplies z0 and z1 that bracket the surface of interest
         icalld = 1
         f = 3  ! assume it's an upward pointing z face

c        Find faces #6 and with z0 < z < z1:
         xmax= glmax(xm1,nx1*ny1*nz1*nelt)
            
         zz_0= xmax/2.0-1.0e-13
         zz_1= xmax/2.0+1.0e-13

         isum= 0
         f   = 3  !assume it's an upward pointing z face
         do e=1,nelv
            call fcsum2(zsum,asum,xm1,e,f)  ! f in prex notation
            if (asum.gt.0) zavg = zsum/asum
            if (zz_0.le.zavg.and.zavg.le.zz_1) then
               flag(f,e) = 1
               isum = isum+1
         !write(6,*) 'checking face numbers =',e,f,xmax,zavg,zz_0 
            endif
         enddo
         iisum=iglsum(isum,1)
         !write(6,*) 'checking face numbers =',isum,iisum,xmax,zavg,zz_0 
         !call exitt

      endif

      !poynting vectors (avgSz,avgISz) computed: cem_energy 
        
      n = nx1*ny1*nz1*nelv

      ubar1 = 0
      atot1 = 0
      ubar2 = 0
      atot2 = 0
      ubar3 = 0
      atot3 = 0

      nkey  = 1
      isum  = 0
      nfaces= 2*ndim

      call usersol(time,shx,shy,shz,sex,sey,sez)
      call vcross (poytSx,poytSy,poytSz,sex,sey,sez,shx,shy,shz,n)
      call vcross (poySx ,poySy ,poySz ,ex ,ey ,ez ,hx ,hy ,hz ,n)
      call vcross (poyISx,poyISy,poyISz,
     $             incex,incey,incez,inchx,inchy,inchz,n)
                       
      do e = 1,nelv
      do f = 1,nfaces     
         if (flag(f,e).eq.nkey) then ! add this to this average
            call fcsum2(usum1,asum1,poytSx,e,f)  ! f in prex notation
            call fcsum2(usum2,asum2,poySx ,e,f)  ! f in prex notation
            call fcsum2(usum3,asum3,poyISx,e,f)  ! f in prex notation
            ubar1 = ubar1 + usum1
            ubar2 = ubar2 + usum2
            ubar3 = ubar3 + usum3
            atot1 = atot1 + asum1
            atot2 = atot2 + asum2
            atot3 = atot3 + asum3
            isum  = isum  + 1
         endif
      enddo
      enddo

      ubar1= glsum(ubar1,1)
      ubar2= glsum(ubar2,1)
      ubar3= glsum(ubar3,1)

      atot1= glsum(atot1,1)
      atot2= glsum(atot2,1)
      atot3= glsum(atot3,1)

      if (istep.ge.1) then
         if (nid.eq.0) write(33,1) nperiod,istep,time,dt,ubar1,ubar2,
     $        ubar3,cspeed,param(69)*nmscale,nopstep,n_period,nx1-1
      endif

      call trans_calculation(ubar1,ubar2,ubar3)

    1 format(2i9,1p7e25.15,3i5)

      return
      end

c-----------------------------------------------------------------------
      subroutine trans_calculation(ubar1,ubar2,ubar3)
      include 'SIZE'
      include 'TOTAL'
      include 'EMWAVE'
      real     ubar1,ubar2,ubar3

      if ((istep.ge.(n_period-1)*nopstep+1).and.
     $    (istep.le. n_period*nopstep)) then

       if (istep.eq.(n_period-1)*nopstep+1) then
           if (nsteps.eq.nopstep) then
               if (nid.eq.0) then
               write(6,*) 'one period? increase # of periods param(14)'
               call exitt
               endif
           else
           trans_tot =  0.0
           trans_scat=  0.0
           trans_inc =  0.0
           endif
       endif
         tmp = dt/cspeed/(param(69)*nmscale)
         trans_tot =trans_tot +ubar1*tmp
         trans_scat=trans_scat+ubar2*tmp
         trans_inc =trans_inc +ubar3*tmp
       if (istep.eq.n_period*nopstep) then
        if (nid.eq.0) write(6,*)  ' '
           transmit_t=trans_tot /trans_inc
           transmit_s=trans_scat/trans_inc
        if (nid.eq.0) then
           write(6,*) '==============================================='
           write(6,*)  n_period,'-th period:'
           write(6,*) '-----------------------------------------------'
           write(6,*) 'period=',(param(69)*nmscale)/cspeed
           write(6,*) 'finaltime=',dt*nsteps
           if (ifnm) then
              write(6,*) 'wavelength(nm)=',param(69)
           else
              write(6,*) 'wavelength= ',param(69)
           endif
           write(6,*) '-----------------------------------------------'
           write(6,*) 'Transmission_Tot =',transmit_t
           write(6,*) 'Transmission_Scat=',transmit_s
           write(6,*)  '=============================================='
        endif
       endif
      endif

      return
      end

c-----------------------------------------------------------------------
      subroutine gl_fcavg(ubar,atot,u,flag,nkey,nx,nelv,ndim)
      real     u(nx,nx,nx,nelv)
      integer  e,f,nkey
      real     ubar,atot
      integer  flag(2*ndim,nelv)

      ubar = 0
      atot = 0

      nfaces= 2*ndim

      do e=1,nelv
      do f=1,nfaces
         if (flag(f,e).eq.nkey) then ! add this to this average
            call fcsum2(usum,asum,u,e,f)  ! f in prex notation
            ubar = ubar + usum
            atot = atot + asum
         endif
      enddo
      enddo

      ubar= glsum(ubar,1)
      atot= glsum(atot,1)
      if (atot.gt.0) ubar = ubar/atot
      return
      end
c-----------------------------------------------------------------------
