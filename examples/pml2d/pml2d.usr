c-----------------------------------------------------------------------
c
c  USER SPECIFIED ROUTINES:
c
c     - boundary conditions
c     - initial conditions
c     - variable properties
c     - forcing function for fluid (f)
c     - forcing function for passive scalar (q)
c     - general purpose routine for checking errors etc.
c
c-----------------------------------------------------------------------
      subroutine userinc
c-----------------------------------------------------------------------
      implicit none
      include 'SIZE'
      include 'TOTAL'
      include 'EMWAVE'
      include 'NEKUSE'
      include 'RK5'

      common /userparam/ omega,eps1,eps2,mu1,mu2,refl,tran
      real omega,eps1,eps2,mu1,mu2,refl,tran

      integer i,j,k
      real ky
      real yy,tt,mu,eps,eta,uinc

      tt = rktime
      do i = 1,ncemincfld
         j = cemincfld(i)
         k = cemface(j)
         yy = ym1(k,1,1,1)
         eps = permittivity(k)
         mu = permeability(k)
         eta = sqrt(mu/eps)
         ky = omega*sqrt(mu*eps)
         uinc = cos(-ky*yy-omega*tt)
         fHN(j,3) = fHN(j,3)+uinc
         fEN(j,1) = fEN(j,1)+eta*uinc
      enddo

      return
      end
c-----------------------------------------------------------------------
      subroutine userini(tt,myhx,myhy,myhz,myex,myey,myez)
c-----------------------------------------------------------------------
      implicit none
      include 'SIZE'
      include 'TOTAL'
      include 'EMWAVE'
      include 'NEKUSE'
      include 'PML'

      real tt
      real myhx(lx1,ly1,lz1,lelt)
      real myhy(lx1,ly1,lz1,lelt)
      real myhz(lx1,ly1,lz1,lelt)
      real myex(lx1,ly1,lz1,lelt)
      real myey(lx1,ly1,lz1,lelt)
      real myez(lx1,ly1,lz1,lelt)

      integer i
      real mu,eps

      call usersol(tt,myhx,myhy,myhz,myex,myey,myez)
c     We need to set the extra PML fields too
      do i = 1,npts
         mu = permeability(i)
         eps = permittivity(i)
         pmlbn(i,1) = mu*myhx(i,1,1,1)
         pmlbn(i,2) = mu*myhy(i,1,1,1)
         pmlbn(i,3) = mu*myhz(i,1,1,1)
         pmldn(i,1) = eps*myex(i,1,1,1)
         pmldn(i,2) = eps*myey(i,1,1,1)
         pmldn(i,3) = eps*myez(i,1,1,1)
      enddo

      return
      end
c-----------------------------------------------------------------------
      subroutine usersol(tt,myshx,myshy,myshz,mysex,mysey,mysez)
c-----------------------------------------------------------------------
      implicit none
      include 'SIZE'
      include 'TOTAL'
      include 'EMWAVE'
      include 'NEKUSE'
      include 'GEOMBOUND'
      include 'PML'

      common /userparam/ omega,eps1,eps2,mu1,mu2,refl,tran
      real omega,eps1,eps2,mu1,mu2,refl,tran

      real tt
      real myshx(lx1,ly1,lz1,lelt)
      real myshy(lx1,ly1,lz1,lelt)
      real myshz(lx1,ly1,lz1,lelt)
      real mysex(lx1,ly1,lz1,lelt)
      real mysey(lx1,ly1,lz1,lelt)
      real mysez(lx1,ly1,lz1,lelt)

      integer e,i,j,l,lx1_2
      real ky
      real yy,mu,eps,eta,d,pmlfac,pmlsigmamax

      lx1_2 = lx1/2
      do e = 1,nelt
         do j = 1,ly1
            do i = 1,lx1
c     Global number
               l = i+nx1*(j-1)+nx1*ny1*(e-1)
               eps = permittivity(l)
               mu = permeability(l)
               eta = sqrt(mu/eps)
               ky = omega*sqrt(eps*mu)
               yy = ym1(i,j,1,e)
               if (ym1(lx1_2,lx1_2,1,e).gt.0.0) then
                  if (pmltag(e).ne.0) then
                     d = pmlouter(4)-pmlinner(4)
                     pmlsigmamax =
     $                    -(pmlorder+1)*log(pmlreferr)/(2*eta*d)
                     pmlfac = (pmlsigmamax*d/(pmlorder+1))
     $                    *((yy-pmlinner(4))/d)**(pmlorder+1)
                  else
                     pmlfac = 0.0
                  endif
                  myshz(i,j,1,e) =
     $                 refl*exp(-eta*pmlfac)*cos(ky*yy-omega*tt)
                  mysex(i,j,1,e) = -eta*myshz(i,j,1,e)
               else
                  if (pmltag(e).ne.0) then
                     d = pmlinner(3)-pmlouter(3)
                     pmlsigmamax =
     $                    -(pmlorder+1)*log(pmlreferr)/(2*eta*d)
                     pmlfac = (pmlsigmamax*d/(pmlorder+1))
     $                    *((pmlinner(3)-yy)/d)**(pmlorder+1)
                  else
                     pmlfac = 0.0
                  endif
                  myshz(i,j,1,e) =
     $                 tran*exp(-eta*pmlfac)*cos(-ky*yy-omega*tt)
                  mysex(i,j,1,e) = eta*myshz(i,j,1,e)
               endif
            enddo
         enddo
      enddo

      return
      end
c-----------------------------------------------------------------------
      subroutine usersrc(baseidx,srchx,srchy,srchz,srcex,srcey,srcez)
c-----------------------------------------------------------------------
c     Add source terms to the fields given in src{e,h}{x,y,z}. Read file
c     doc/rea-file.txt for specification. Since we want to make it
c     possible to have several sources, we specify a `baseidx' relative
c     to which all parameters are read.
      implicit none
      include 'SIZE'
      include 'TOTAL'
      include 'EMWAVE'
      include 'NEKUSE'

      integer baseidx
      real srchx(lx1,ly1,lz1,lelt),
     $     srchy(lx1,ly1,lz1,lelt),
     $     srchz(lx1,ly1,lz1,lelt),
     $     srcex(lx1,ly1,lz1,lelt),
     $     srcey(lx1,ly1,lz1,lelt),
     $     srcez(lx1,ly1,lz1,lelt)

      return
      end
c-----------------------------------------------------------------------
      subroutine uservp (ix,iy,iz,iel)
c-----------------------------------------------------------------------
      implicit none
      include 'SIZE'
      include 'TOTAL'
      include 'EMWAVE'
      include 'NEKUSE'

      integer ix,iy,iz,iel

      common /userparam/ omega,eps1,eps2,mu1,mu2,refl,tran
      real omega,eps1,eps2,mu1,mu2,refl,tran

      integer ielg,nx1_2

c     Get local element number from global element number
      iel = gllel(ielg)
      nx1_2 = nx1/2
      if (ym1(nx1_2,nx1_2,nx1_2,ielg).gt.0) then
c     Upper region
         permit_r = eps1
         permea_r = mu1
      else
c     Lower region
         permit_r = eps2
         permea_r = mu2
      endif
      permit = permit_r*permit_0
      permea = permea_r*permea_0

      return
      end
c-----------------------------------------------------------------------
      subroutine userq(ix,iy,iz,ieg)
c-----------------------------------------------------------------------
      include 'SIZE'
      include 'TOTAL'
      include 'NEKUSE'

      qvol = 0.0
      source = 0.0

      return
      end
c-----------------------------------------------------------------------
      subroutine useric(ix,iy,iz,ieg)
c-----------------------------------------------------------------------
      include 'SIZE'
      include 'TOTAL'
      include 'NEKUSE'

      return
      end
c-----------------------------------------------------------------------
      subroutine userbc(ix,iy,iz,iside,ieg)
c-----------------------------------------------------------------------
      include 'SIZE'
      include 'TOTAL'
      include 'NEKUSE'

      ux = 0.0
      uy = 0.0
      uz = 0.0
      temp = 0.0

      return
      end
c-----------------------------------------------------------------------
      subroutine usrdat
c-----------------------------------------------------------------------
      include 'SIZE'
      include 'TOTAL'
      include 'EMWAVE'
      include 'NEKUSE'

      common /userparam/
     $     omega,               ! frequency of the incident wave
     $     eps1,                ! permittivity in upper region
     $     eps2,                ! permittivity in lower region
     $     mu1,                 ! permeability in upper region
     $     mu2,                 ! permeability in lower region
     $     refl,                ! reflection coefficient
     $     tran                 ! transmission coefficient

      real omega,eps1,eps2,mu1,mu2,refl,tran

      omega = 5.0
      eps1 = 1.0
      eps2 = 1.0
      mu1 = 1.0
      mu2 = 1.0

      z1 = sqrt(mu1/eps1)
      z2 = sqrt(mu2/eps2)
      refl = (z1-z2)/(z1+z2)
      tran = 2*z1/(z1+z2)

      return
      end
c-----------------------------------------------------------------------
      subroutine usrdat2
c-----------------------------------------------------------------------
c     Use this subroutine to set the dimensions of the domain.
      implicit none
      include 'SIZE'
      include 'TOTAL'
      include 'EMWAVE'
      include 'NEKUSE'
      include 'GEOMBOUND'

      integer e,f,i,j,n,nxy2
      real glmin,glmax
      real sx,sy,sz,xmid,ymid,zmid

      n = nx1*ny1*nz1*nelv

      xmin = glmin(xm1,n)
      xmax = glmax(xm1,n)
      ymin = glmin(ym1,n)
      ymax = glmax(ym1,n)
      zmin = glmin(zm1,n)
      zmax = glmax(zm1,n)

      sx = 5.0
      sy = 10.0
      if (if3d) sz = 5.0

      do i = 1,n
         xm1(i,1,1,1) = sx*(xm1(i,1,1,1)-xmin)/(xmax-xmin)-(sx/2.0)
         ym1(i,1,1,1) = sy*(ym1(i,1,1,1)-ymin)/(ymax-ymin)-(sy/2.0)
         if (if3d) then
            zm1(i,1,1,1) = sz*(zm1(i,1,1,1)-zmin)/(zmax-zmin)-(sz/2.0)
         endif
      enddo

      return
      end
c-----------------------------------------------------------------------
      subroutine userfmarker
c-----------------------------------------------------------------------
      implicit none
      include 'SIZE'
      include 'TOTAL'
      include 'EMWAVE'
      include 'NEKUSE'
      include 'GEOMBOUND'

      logical markinc,mark2d
      integer e,f,i,j,k,nx1_2

      nx1_2 = nx1/2
c     Mark the faces where the incident field needs to be added
      do e = 1,nelt
         if (ym1(nx1_2,nx1_2,1,e).gt.0.0) then
            markinc = .true.
            do f = 1,nfaces
               do i = 1,nxzf
c     j is the global face number
                  j = (e-1)*nxzf*nfaces+nxzf*(f-1)+i
c     k is the volume global number associated with face j.
                  k = cemface(j)
                  if (abs(ym1(k,1,1,1)).gt.1e-8) then
                     markinc = .false.
                     exit
                  endif
               enddo
               if (markinc) then
                  do i = 1,nxzf
                     j = (e-1)*nxzf*nfaces+nxzf*(f-1)+i
                     fincmarker(j) = 1
                  enddo
               endif
            enddo
         endif
      enddo

      return
      end
c-----------------------------------------------------------------------
      subroutine userft
c-----------------------------------------------------------------------
      include 'SIZE'
      include 'TOTAL'
      include 'EMWAVE'


      return
      end
c-----------------------------------------------------------------------
      subroutine userchk
c-----------------------------------------------------------------------
      include 'SIZE'
      include 'TOTAL'
      include 'EMWAVE'
      include 'PML'

      common /ccpu/ cpu_t,cpu_dtime,cpu_chk

c     compute errors
      if (istep.le.10.or.mod(istep,iocomm).eq.0) then
         ntott = nx1*ny1*nz1*nelt
         npts3 = nx1*ny1*nz1*nelt*3
         nsrf  = nx1*nz1*nelt*6

         if (ifsol) then
            call usersol(time,sHN(1,1),sHN(1,2),sHN(1,3),
     $           sEN(1,1),sEN(1,2),sEN(1,3))
         else
            call rzero(sHN, npts3)
            call rzero(sEN, npts3)
         endif

         call sub3(ErrHN(1,1),SHN(1,1),HN(1,1),NTOTT)
         call sub3(ErrHN(1,2),SHN(1,2),HN(1,2),NTOTT)
         call sub3(ErrHN(1,3),SHN(1,3),HN(1,3),NTOTT)
         call sub3(ErrEN(1,1),SEN(1,1),EN(1,1),NTOTT)
         call sub3(ErrEN(1,2),SEN(1,2),EN(1,2),NTOTT)
         call sub3(ErrEN(1,3),SEN(1,3),EN(1,3),NTOTT)
c     Uncomment this section to zero the error in the PML.
c$$$         nxyz = nx1*ny1*nz1
c$$$         do e = 1,maxpml  
c$$$            ie = pmlptr(e)
c$$$            do i = 1,nxyz
c$$$               j = i+nxyz*(ie-1)
c$$$               ErrHN(j,1) = 0.0
c$$$               ErrHN(j,2) = 0.0
c$$$               ErrHN(j,3) = 0.0
c$$$               ErrEN(j,1) = 0.0
c$$$               ErrEN(j,2) = 0.0
c$$$               ErrEN(j,3) = 0.0
c$$$            enddo
c$$$         enddo
c     Uncomment this section to zero the error not in the PML
c$$$         nxyz = nx1*ny1*nz1
c$$$         do e = 1,nelt
c$$$            if (pmltag(e).eq.0) then
c$$$               do i = 1,nxzy
c$$$                  j = i+nxyz*(e-1)
c$$$                  ErrHN(j,1) = 0.0
c$$$                  ErrHN(j,2) = 0.0
c$$$                  ErrHN(j,3) = 0.0
c$$$                  ErrEN(j,1) = 0.0
c$$$                  ErrEN(j,2) = 0.0
c$$$                  ErrEN(j,3) = 0.0
c$$$               enddo
c$$$            endif
c$$$         enddo

         HXmr = glamax(ErrHN(1,1),NTOTT)
         HYmr = glamax(ErrHN(1,2),NTOTT)
         HZmr = glamax(ErrHN(1,3),NTOTT)
         EXmr = glamax(ErrEN(1,1),NTOTT)
         EYmr = glamax(ErrEN(1,2),NTOTT)
         EZmr = glamax(ErrEN(1,3),NTOTT)

         HXer = glsc3(ErrHN(1,1),bm1,ErrHN(1,1),NTOTT)/ volvm1
         HYer = glsc3(ErrHN(1,2),bm1,ErrHN(1,2),NTOTT)/ volvm1
         HZer = glsc3(ErrHN(1,3),bm1,ErrHN(1,3),NTOTT)/ volvm1
         EXer = glsc3(ErrEN(1,1),bm1,ErrEN(1,1),NTOTT)/ volvm1
         EYer = glsc3(ErrEN(1,2),bm1,ErrEN(1,2),NTOTT)/ volvm1
         EZer = glsc3(ErrEN(1,3),bm1,ErrEN(1,3),NTOTT)/ volvm1

         if (hxer.gt.0) hxer = sqrt(hxer)
         if (hyer.gt.0) hyer = sqrt(hyer)
         if (hzer.gt.0) hzer = sqrt(hzer)
         if (exer.gt.0) exer = sqrt(exer)
         if (eyer.gt.0) eyer = sqrt(eyer)
         if (ezer.gt.0) ezer = sqrt(ezer)

         snel = nelt + .5
         snel = sqrt(snel)
         nels = snel
         nnn  = nx1-1
         npt1 = nnn*nels
         npts = nx1*ny1*nz1*nelt ! npts = npt1**ndim

         if (istep.eq.0) cpu_p_t = 0
         if (istep.gt.0) cpu_p_t = cpu_t/(npts*istep)
         if (istep.eq.nsteps) cpu_p_t = glsum(cpu_p_t,1)/np

         if (nid.eq.0) then

            if (istep.eq.1) write(6,90)
            write(6,91) ISTEP,nelt,nels,nnn,npt1,npts
     $           ,time,dt,HXer,HYer,HZer,EXer,EYer,EZer,cpu_t,cpu_p_t
            write(6,95) ISTEP,nelt,nels,nnn,npt1,npts
     $           ,time,dt,HXmr,HYmr,HZmr,EXmr,EYmr,EZmr,cpu_t,cpu_p_t

 90         format(/,'    istep   nelt  nels  N  npt1    npts   time
     $  dt     HXerr     HYerr     HZerr     EXerr     EYerr     EZerr
     $  cpu_t   cpu_t_pts')
 91         format(/,i10,3i5,i5,i9,1p9e10.3,e9.2,' CPU: L2  '  )
 95         format(  i10,3i5,i5,i9,1p9e10.3,e9.2,' CPU: Linf'  )
         endif
      endif

      return
      end
c-----------------------------------------------------------------------
